# <div>ДАКУМЕНТАЦЫЯ </div>
# Палілінгвальнасць
Пачаць, мабыць, варта з палiлiнгвальнацi, таму што менавіта яна вырашае як менавіта вы хочаце пісаць код на triple.
Палiлiнгвальнасць дазваляе пісаць код з лакалізацыяй. Іншымі словамі лексіка triple падтрымлівае некалькі чалавечых моў. 
На момант версіі 1.0 інтэрпрэтатар падтрымлівае тры лакалізацыі.

Англійская Лакалізацыя:
```haskell
: Stream() -> num =>
     return 0
```
Беларуская Лакалізацыя:
```haskell
: Струмень() -> лік =>
     вярнуць 0
```
Руская Лакалізацыя:
```haskell
: Поток () -> число =>
     вернуть 0
```
Канструкцыі мовы будуць разгледжаны ў наступных раздзелах

# Увод/Вывад
Традыцыяй знаёмства з любым новым мовай праграмавання з'яўляецца напісанне праграмы вываду `Hello World`.
Звычайна менавіта з гэтай праграмы пачынаецца шлях любога праграміста.
У Triple тэкст можна вывесці з дапамогай двух функцый - `>>Вывад()` і `>>Вывадлн()`.
Другая, у адрозненне ад першай, пасля вываду радкі ў кансоль отсутпает на наступны радок.

Давайце разгледзім прыклад:

```haskell
: Струмень() -> лік =>
    >>Вывад("Hello world!")
    вярнуць 0
```

Вось што мы ўбачым у кансолі:

`Hello world!`

`Праграма завяршылася з кодам: 0`

Калі трэба ўвесці дадзеныя, то ўжываецца функцыя `>>Вводлн`.

Разгледзім прыклад:

Папярэдне выведзем тое што ўвялі, інакш інтэрпрэтатар выдасць памылку.
```haskell
: Струмень() -> лік =>
    >>Вывад(>>Уводлн())
    вярнуць 0
```
У кансолі мы ўбачым перарывісты сімвал ніжняга падкрэслення, інтэрпрэтатар будзе чакаць пакуль дадзеныя будуць уведзены.
Цяпер адлюструецца тэкст, які вы ўвялі!

Паток(Струмень) з'яўляецца функцыяй-кропкай ўваходу ў праграму. Усе канструкцыі мовы (за выключэннем функцый і структур) абавязаны знаходзіцца ў патоку. Паток можна аб'яўляць толькі адзін раз.


# Тыпы дадзеных
У triple з-за статычнай тыпізацыі трэба відавочна аб'яўляць тыпы.

### Тыпы Triple:

* лікавы тып ' лік`

* радковы тып ' радок`

* знакавы тып ' сімвал`

* лагічны тып ' логіка`

### А таксама існуюць складаныя тыпы:
* мноства
* функцыя


# Пераменная
У мінулым раздзеле мы казалі пра тыпы дадзеных, так вось іх асноўным спосабам прымянення з'яўляецца стварэнне зменных.
Для стварэння зменных выкарыстоўваецца канструкцыя:
'хай <імя> -> <тып> = <Значэнне>`< br>
Пераменным можна прысвойваць любыя імёны, галоўнае каб яны не паўтараліся.

Але акрамя іх стварэння іх можна і выкарыстоўваць.

```haskell
: Струмень() -> лік =>
    хай переменная1 -> радок = "Hello World!"
    >>Вывад(переменная1)
    вярнуць 0
```
У кансоль атрымаем `Hello World!`

У выпадку прысвойвання сінтаксіс банальны:

```haskell
: Струмень() -> лік =>
    хай переменная2 -> сімвал = 'д'
    пераменная2 = 'г'
    >>Вывад(переменная2)
    вярнуць 0
```
У консоле ўбачым: `Ч`

# Аператары 
У triple падтрымліваюцца базавыя матэматычныя аператары:

* Сума `+`
* Рознасьць `-`
* Твор `*`
* Дзяленне `/`
* Узвядзенне ў ступень`^'
* Дзяленне па модулю `%`

Працуюць аператары толькі з лічбавым тыпам дадзеных і радковым ў выпадку канкатэнацыі.

```haskell
: Струмень() -> лік =>
    хай а -> лік = 10
    хай б -> лік = 2
    >>Вывад((а * (4 + 5))/б)
    вярнуць 0
```

# Аператары параўнання
Аператары параўнання патрэбныя для працы якога-небудзь ўмовы галінавання або цыклу, якія мы разгледзім у наступных раздзелах. Вось аператары параўнання:

* Раўняецца `==`
* Не раўняецца `!=`
* Больш чым `>`
* Менш чым `<`
* Больш альбо роўна чым `>=`
* Менш альбо роўна чым `<=`

Варта адзначыць розніцу паміж аператарам прысвойвання `=` і аператарам роўнасці `==`. Прысвойванне трэба для замены выразы зменнай, а параўнанне толькі для сравнивания значэнняў у якім-небудзь ўмове.

Аператары параўнання працуюць толькі з лічбавым тыпам дадзеных.

# Галінаванне
У мове галінаванне вызначаецца наступным чынам: `калі <умова> => <дзеянне> 
 iкалi <умова> => <дзеянне> 
 інакш => <дзеянне>`

Прыклад:

```haskell
: Струмень() -> лік =>
    калі 1 > 2 => >>Вывад(1)
    iкалi 1 == 1 => >>Вывад(2)
    інакш => >>Вывад(3)
    вярнуць 0
```

Кансоль: `2`

Таксама падтрымліваюцца блокі сцвярджэнняў:
 

```haskell
: Струмень() -> лік =>
    хай а -> лік = 1
    хай б -> лік = 2
    хай в -> лік = 3
    
    калі а > 0 =>
        | а = а + 1
        | калі а == б => б = б + 1
        | калі б == в => >>Вывод("выканана")]
    інакш => >>Вывад("непрадбачаная арыфметыка")

    вярнуць 0
```

Кансоль: `Выканана`

Калі выкарыстоўваць блокі, то трэба ставіць сімвал `/` для кожнага зацвярджэння. Пасля таго як блок будзе скончаны, трэба ставiць `]`.



# Цыклы
Цыклы з'яўляюцца неад'емнай часткай любога мовы праграмавання, triple не стаў выключэннем. У мове падтрымліваюцца два віды цыклаў. 

Першы выгляд цыкла заключаецца ў тым, што ён спачатку правярае праўдзівасць ўмовы, а потым нешта выконвае, пакуль яно праўдзіва:

```haskell
: Струмень() -> лік =>
    пакуль 1 > 0 => >>Вывад(1)
    вярнуць 0
```
Кансоль: `11111111111...`

У дадзеным выпадку ў нас нішто і нідзе не абнаўляецца, адзінка заўсёды больш за нуль, ўмова застаецца статычным, адсюль цыкл атрымаецца бясконцым. Каб гэтага пазбегнуць, давайце разгледзім прыклад:

```haskell
: Струмень() -> лік =>
    хай а -> лік = 0
    пакуль а <= 10 =>
        | >>Вывад(а) 
        | а = а + 1 ]
    вярнуць 0
```

Кансоль: `012345678910`

Спачатку мы ствараем зменную, далей параўноўваем гэтую зменную з 10, бо значэнне зменнай роўна нулю, параўноўваем 0 <= 10? - так, выводзім 0, далей абнаўляем зменную `а': дадаем да яе адзінку, зноў параўноўваем 1 < = 10? - так, выводзім 1, далей зноў абнаўляем зменную, і так далей па такой жа аналогіі, пакуль пераменная не стане роўная 11: параўноўваем 11 <= 10? - не, цыкл абрываецца і праграма завяршаецца. Варта адзначыць, што ўсе цыклы падтрымліваюць такі ж блок сцвярджэнняў як і галінаванне: `| ]`.

Ёсць яшчэ адзін від цыклу:`выконваць-пакуль'. Яго сутнасць заключаецца такі ж, як і ў звычайнага цыклу `пакуль`, за выключэннем таго, што гэты від цыклу спачатку што-небудзь робіць(выконвае), а потым толькі параўноўвае. Прынцыповае адрозненне можна паглядзець на прыкладах:

цыкл 'пакуль`

```haskell
: Струмень() -> лік =>
    хай г -> лік = 4
    
    пакуль г < 3 => >>Вывад(г)

    вярнуць 0
```

У консоле нічога не выдасць.


цыкл 'выконваць-пакуль`

```haskell
: Паток () - > лік =>
    хай г - > лік = 4
    
    выконваць => >>Вывад(г)
    пакуль г < 3 ]

    вярнуць 0
```

Кансоль: `4`

Адрозненне ў тым, што цыкл `выконваць-пакуль` паспявае вывесці значэнне, да моманту, калі адбудуцца параўнання значэнняў, у той час, пакуль цыкл `пакуль` адразу ж параўноўвае значэння і нічога не выводзіць бо ўмова ілжыва.

# Калекцыя
У Triple няма масіваў, замест іх існуе калекцыі. 
Калекцыя мноства з'яўляецца складаным тыпам дадзеных, яно дазваляе захоўваць у зменнай некалькі значэнняў, прычым значэння могуць быць любых тыпаў дадзеных. Разгледзім прыклад:

```haskell
: Струмень() - > лік =>
    хай А - > мноства = {1,2,3,4,5}
    >>Вывад(А[1]) 

    вярнуць 0
```

Кансоль: `2`

Выклікаць элементы мноства трэба праз канструкцыю: `<імя_мноства>[элемент па індэксе]`. Індэксацыя мноства пачынаецца з нуля, гэта значыць у першага элемента мноства заўсёды нулявы індэкс, у другога індэкс роўны адзінцы і гэтак далей. 

Мноства падтрымлівае механізм `<iмя_мноства>[колькасць]` вываду ўсёй колькасці яго элементаў. Разгледзім прыклад:

```haskell
: Струмень() -> лік =>
    хай Б -> мноства = {'а', 'б', 'в'}
    хай а -> лік = 0
    пакуль а < Б[колькасць] =>
        | >>Вывад(Б[а])
        | а = а + 1 ]
    вярнуць 0
```

Кансоль `абв`

Тут цыкл патрэбен для вываду на кансоль ўсіх элементаў мноства. Ён выконваецца пакуль `а 'менш чым колькасць элементаў мноства 'б', гэта значыць спачатку ідзе праверка 0 < 3? потым 1 < 3? і апошняя праверка 3 < 3? тут цыкл і абрываецца.


# Функцыi
Функцыі з'яўляюцца падпраграмамі і складанымі тыпамі дадзеных. У іх ёсць свая лакальная вобласць бачнасці, іншымі словамі яе дадзеныя даступныя толькі ў яе межах, таму і атрымліваецца падпраграма. Функцыі вызначаюцца праз першы знак:
`:`

```haskell
: Прывітанне() -> радок =>
    | хай вынік -> радок = "Прывітанне"
    | вярнуць вынік ]
```  

У кансоле нічога не выведзе.

Функцыя арыентаваная на матэматычную натацыю, яна абавязаная нешта вяртаць, у дадзеным прыкладзе калі функцыю разглядаць як матэматычную, то яна прымае нічога, а Вяртае радок, таму ў канцы функцыі трэба пісаць ключавое слова `вярнуць`.

Функцыі з'яўляюцца глабальнымі сцвярджэннямі, такім чынам іх можна аб'яўляць на ўзроўні функцыі `паток`, але нельга аб'яўляць ўнутры патоку.

Каб выкарыстоўваць патэнцыял функцый, іх трэба выклікаць. Калі мы выклічам функцыю `прывітанне()` ў патоку, то зможам убачыць вынік яе выканання ў консоле:

```haskell
: Прывітанне() -> радок =>
    | хай вынік -> радок = "Прывітанне"
    | вярнуць вынік ]

: Струмень() -> лік =>
    >>Вывад(>>Прывітанне())
    вярнуць 0
```  

Кансоль: `Прывітанне`

Выклік функцыі ажыццяўляецца праз `>>`. Бо функцыя вяртала вынік з тыпа `радок`, то пры яе выкліку яна па сутнасці становіцца значэннем са радковым тыпам дадзеных, мы маглі б і напісаць:

```haskell
: Прывітанне() -> радок =>
    | хай вынік -> радок = "Прывітанне"
    | вярнуць вынік ]

: Струмень() -> лік =>
    хай а -> радок = >>Прывітанне()
    >>Вывад(а)
    вярнуць 0
```

Кансоль: `Прывітанне`

Вось некалькі правілаў пры аб'яўленні функцый:
* Функцыі варта аб'яўляць з першай вялікай літарай;
* Функцыі абавязаны што-небудзь вяртаць;
* Укладзеных функцый не існуе;

Бо функцыя `Струмень` таксама з'яўляецца функцыяй, то правілы распаўсюджваюцца і на яе. Паток можа вяртаць любы тып дадзеных і выраз:

```haskell
: Струмень() -> логіка => 
     >>Вывад(0)
     вярнуць ісціна 
```
Кансоль: `0`
`the program exited with the code: true`

Функцыі могуць прымаць параметры, любога тыпу дадзеных. Разгледзім прыклад:

```haskell
: Сума (а -> лік, б -> лік) -> лік =>
     | вярнуць а + б ]

: Струмень() -> лік =>
     >>Вывад(>>Сума(2,8))
     вярнуць 0
```
Кансоль: `10`

Пры выкліку функцыі мы туды запісваем значэння, названыя аргументамі. Параметры і аргументы пералічваюцца праз коску.

# Працэдуры
Працэдуры з'яўляюцца прыватным выпадкам функцый. Яны заўсёды вяртаюць `нішто`:

```haskell
: Твор(а -> лік, б -> лік) -> нішто => 
      | >>Вывад(а * б) ]

: Струмень() -> лік =>
      >>Твор(5,5)
      вярнуць 0
```

Кансоль: `25`

Бо функцыя нічога не вяртае, пажадана там выклікаць функцыю вываду, калі мы хочам што-б яна хоць нешта адлюстравала.

Працэдуры вельмі лаканічныя пры з выкліку:

```haskell
: Струмень() -> лік =>
     >>Фактарыял(5)
     вярнуць 0

: Фактарыяла (а -> лік) -> нішто =>
     | хай вынік -> лік = 1
     | хай індэкс -> лік = 1
     | пакуль індэкс <= а =>
           | вынік = вынік * індэкс 
           | індэкс = індэкс + 1 ]
     | >>Вывад(вынік) ]
```
Кансоль: `120`

# Канструкцыi
Канструкцыi з'яўляюцца абалонкай для функцый, а таксама з'яўляюцца глабальнымі сцвярджэннямі, то ёсць канструкцыi можна аб'яўляць на ўзроўні функцый. 
Канструкцыi не могуць быць укладзенымі і не могуць утрымлівацца ў патоку. Вызначаюцца першым сімвалам `::` і словам `канструкцыя`

Прыклад:

```haskell
:: канструкцыя Фігура
    : Квадрат() -> нішто => >>Вывад("гэта квадрат")
    мяжа
```

Канструкцыя абавязаная завяршацца ключавым словам `мяжа`.

Канструкцыi можна выклікаць з дапамогай сімвала `<<`:

```haskell
: Струмень() -> лік =>
     <<Фігура >>Круг
     вярнуць 0

:: структура Фігура
     : Квадрат() -> нішто => >>Вывад("гэта квадрат")
     : Круг() -> нішто => >>Вывад("гэта круг")
     : Трохкутнік() -> нішто => >>Вывад("гэта трохкутнік")
     мяжа
```

Кансоль `гэта круг`

Структуры патрэбныя для структурызацыі кода, разбітыя яго на блокі.



