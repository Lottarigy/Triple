# <div>ДАКУМЕНТАЦЫЯ < /div>
# Палілінгвальнасць
Пачаць, мабыць, варта з палiлiнгвальнацi, таму што менавіта яна вырашае як менавіта вы хочаце пісаць код на triple.
Палiлiнгвальнасць дазваляе пісаць код з лакалізацыяй. Іншымі словамі лексіка triple падтрымлівае некалькі чалавечых моў. 
На момант версіі 1.0 інтэрпрэтатар падтрымлівае тры лакалізацыі.

Англійская Лакалізацыя:
```haskell
: Stream() -> num =>
     return 0
```
Беларуская Лакалізацыя:
```haskell
: Струмень() -> лік =>
     вярнуць 0
```
Руская Лакалізацыя:
```haskell
: Поток () - > число =>
     вернуть 0
```
Канструкцыі мовы будуць разгледжаны ў наступных раздзелах

# Увод/Вывад
Традыцыяй знаёмства з любым новым мовай праграмавання з'яўляецца напісанне праграмы вываду `Hello World`.
Звычайна менавіта з гэтай праграмы пачынаецца шлях любога праграміста.
У Triple тэкст можна вывесці з дапамогай двух функцый - `>>Вывад()` і `>>Вывадлн()`.
Другая, у адрозненне ад першай, пасля вываду радкі ў кансоль отсутпает на наступны радок.

Давайце разгледзім прыклад:

```haskell
: Струмень() -> лік =>
    >>Вывад("Hello world!")
    вярнуць 0
```

Вось што мы ўбачым у кансолі:

`Hello world!`

'Праграма завяршылася з кодам: 0`

Калі трэба ўвесці дадзеныя, то ўжываецца функцыя `>>Вводлн`.

Разгледзім прыклад:

Папярэдне выведзем тое што ўвялі, інакш інтэрпрэтатар выдасць памылку.
```haskell
: Струмень() -> лік =>
    >>Вывад(>>Уводлн())
    вярнуць 0
```
У кансолі мы ўбачым перарывісты сімвал ніжняга падкрэслення, інтэрпрэтатар будзе чакаць пакуль дадзеныя будуць уведзены.
Цяпер адлюструецца тэкст, які вы ўвялі!

Паток(Струмень) з'яўляецца функцыяй-кропкай ўваходу ў праграму. Усе канструкцыі мовы (за выключэннем функцый і структур) абавязаны знаходзіцца ў патоку. Паток можна аб'яўляць толькі адзін раз.


# Тыпы дадзеных
У triple з-за статычнай тыпізацыі трэба відавочна аб'яўляць тыпы.

### Тыпы Triple:

* лікавы тып ' лік`

* радковы тып ' радок`

* знакавы тып ' сімвал`

* лагічны тып ' логіка`

### А таксама існуюць складаныя тыпы:
* мноства
* функцыя


# Пераменная
У мінулым раздзеле мы казалі пра тыпы дадзеных, так вось іх асноўным спосабам прымянення з'яўляецца стварэнне зменных.
Для стварэння зменных выкарыстоўваецца канструкцыя:
'хай <імя> -> <тып> = <Значэнне>`< br>
Пераменным можна прысвойваць любыя імёны, галоўнае каб яны не паўтараліся.

Але акрамя іх стварэння іх можна і выкарыстоўваць.

```haskell
: Струмень() -> лік =>
    хай переменная1 -> радок = "Hello World!"
    >>Вывад(переменная1)
    вярнуць 0
```
У кансоль атрымаем `Hello World!`

У выпадку прысвойвання сінтаксіс банальны:

```haskell
: Струмень() -> лік =>
    хай переменная2 -> сімвал = 'д'
    пераменная2 = 'г'
    >>Вывад(переменная2)
    вярнуць 0
```
У консоле ўбачым: `Ч`

# Аператары 
У triple падтрымліваюцца базавыя матэматычныя аператары:

* Сума `+`
* Рознасьць `-`
* Твор `*`
* Дзяленне `/`
* Узвядзенне ў ступень`^'
* Дзяленне па модулю `%`

Працуюць аператары толькі з лічбавым тыпам дадзеных і радковым ў выпадку канкатэнацыі.

```haskell
: Струмень() -> лік =>
    хай а -> лік = 10
    хай б -> лік = 2
    >>Вывад((а * (4 + 5))/б)
    вярнуць 0
```

# Аператары параўнання
Аператары параўнання патрэбныя для працы якога-небудзь ўмовы галінавання або цыклу, якія мы разгледзім у наступных раздзелах. Вось аператары параўнання:

* Раўняецца `==`
* Не раўняецца `!=`
* Больш чым `>`
* Менш чым `<`
* Больш альбо роўна чым `>=`
* Менш альбо роўна чым `<=`

Варта адзначыць розніцу паміж аператарам прысвойвання `=` і аператарам роўнасці `==`. Прысвойванне трэба для замены выразы зменнай, а параўнанне толькі для сравнивания значэнняў у якім-небудзь ўмове.

Аператары параўнання працуюць толькі з лічбавым тыпам дадзеных.

# Галінаванне
У мове галінаванне вызначаецца наступным чынам: `калі <умова> => <дзеянне> 
 iкалi <умова> => <дзеянне> 
 інакш => <дзеянне>`

Прыклад:

```haskell
: Струмень() -> лік =>
    калі 1 > 2 => >>Вывад(1)
    iкалi 1 == 1 => >>Вывад(2)
    інакш => >>Вывад(3)
    вярнуць 0
```

Кансоль: `2`

Таксама падтрымліваюцца блокі сцвярджэнняў:
 

```haskell
: Струмень() -> лік =>
    хай а -> лік = 1
    хай б -> лік = 2
    хай в -> лік = 3
    
    калі а > 0 =>
        | а = а + 1
        | калі а == б => б = б + 1
        | калі б == в => >>Вывод("выканана")]
    інакш => >>Вывад("непрадбачаная арыфметыка")

    вярнуць 0
```

Кансоль: `Выканана`

Калі выкарыстоўваць блокі, то трэба ставіць сімвал `/` для кожнага зацвярджэння. Пасля таго як блок будзе скончаны, трэба ставiць `]`.

